{"version":3,"file":"index.js","sources":["../node_modules/stream-lite/es/util/pipe.js","../node_modules/stream-lite/es/internal/helpers.js","../node_modules/stream-lite/es/statics/fromPromise.js","../node_modules/stream-lite/es/core/subscribe.js","../node_modules/stream-lite/es/core/proto.js","../node_modules/stream-lite/es/internal/base-error.js","../node_modules/stream-lite/es/internal/base-create.js","../node_modules/stream-lite/es/internal/base-next.js","../node_modules/stream-lite/es/internal/traversals.js","../node_modules/stream-lite/es/internal/upchain-notification.js","../node_modules/stream-lite/es/internal/base-complete.js","../node_modules/stream-lite/es/core/create.js","../node_modules/stream-lite/es/operators/filter.js","../node_modules/stream-lite/es/operators/switchMap.js","../src/createEpicMiddleware.js","../node_modules/stream-lite/es/statics/merge.js","../src/combineEpics.js"],"sourcesContent":["var pipe = function pipe() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return fns.length === 1 ? fns[0] : fns.reduce(function (f, g) {\n    return function () {\n      return g(f.apply(void 0, arguments));\n    };\n  });\n};\n\nexport { pipe };","import { fromPromise } from '../statics';\nexport var isActive = function isActive(s) {\n  return s.active === true;\n};\nexport var isInactive = function isInactive(s) {\n  return !isActive(s);\n};\nexport var isProducerStream = function isProducerStream(s) {\n  return s.dependencies.length === 0 && s.producer;\n};\nexport var toStream = function toStream(s) {\n  return s.then ? fromPromise(s) : s;\n};\nexport var hasNoSubscribers = function hasNoSubscribers(s) {\n  return s.subscribers.length === 0;\n};\nexport var hasNoActiveDependencies = function hasNoActiveDependencies(s) {\n  return s.dependencies.every(isInactive);\n};\nexport var hasNoActiveDependents = function hasNoActiveDependents(s) {\n  return s.dependents.every(isInactive);\n};\nexport var removeSubscriber = function removeSubscriber(s, subscriber) {\n  return s.subscribers = s.subscribers.filter(function (sub) {\n    return sub !== subscriber;\n  });\n};\nexport var deactivationGuard = function deactivationGuard(s) {\n  return hasNoSubscribers(s) && hasNoActiveDependents(s);\n};\nexport function activateStream(s) {\n  s.active = true;\n  s.hasEmitted = false;\n  s.onStart();\n}\nexport function startProducer(s) {\n  s.producer && s.producer.start(s);\n}\nexport function deactivateStream(s) {\n  s.active = false;\n  s.onStop();\n  s.producer && s.producer.stop();\n}","import { create } from '../core';\nexport var fromPromise = function fromPromise(promise) {\n  var producer = {\n    cancelled: false,\n    start: function start(self) {\n      var _this = this;\n\n      this.cancelled = false;\n\n      if (!promise.then) {\n        self.next(promise);\n        self.complete();\n        return;\n      }\n\n      promise.then(function (x) {\n        if (!_this.cancelled) {\n          self.next(x);\n          self.complete();\n        }\n      }, function (error) {\n        if (!_this.cancelled) self.error(error);\n      });\n    },\n    onStop: function onStop() {\n      this.cancelled = true;\n    }\n  };\n  return create(producer);\n};","import { notifyUpTheChainOn } from '../internal';\nimport * as helpers from '../internal/helpers';\nexport function subscribe(nextOrSubscriber, error, complete) {\n  nextOrSubscriber = nextOrSubscriber || function () {};\n\n  error = error || function (err) {\n    throw new Error(err);\n  };\n\n  complete = complete || function () {};\n\n  var subscriber = typeof nextOrSubscriber === 'function' ? {\n    next: nextOrSubscriber,\n    error: error,\n    complete: complete\n  } : nextOrSubscriber;\n  return function (stream) {\n    stream.subscribers.push(subscriber);\n\n    if (stream.subscribers.length === 1) {\n      helpers.activateStream(stream);\n      helpers.isProducerStream(stream) && helpers.startProducer(stream);\n      notifyUpTheChainOn(stream, 'activated');\n    }\n\n    return {\n      unsubscribe: function unsubscribe() {\n        if (helpers.hasNoSubscribers(stream)) return;\n        helpers.removeSubscriber(stream, subscriber);\n\n        if (helpers.hasNoSubscribers(stream)) {\n          if (helpers.hasNoActiveDependents(stream)) {\n            helpers.deactivateStream(stream);\n            notifyUpTheChainOn(stream, 'completed');\n          }\n        }\n      }\n    };\n  };\n}","import { baseNext, baseNextGuard, baseError, baseComplete } from '../internal';\nimport { pipe as _pipe } from '../util/pipe';\nimport { subscribe as _subscribe } from './subscribe'; // Although it is not the recommended way\n// methods may be added onto proto with\n// import 'stream-lite/add/operators/X'\n\nvar proto = {\n  subscribe: function subscribe() {\n    return _subscribe.apply(void 0, arguments)(this);\n  },\n  next: function next(value) {\n    baseNext(this, value);\n  },\n  error: function error(_error) {\n    baseError(this, _error);\n  },\n  complete: function complete() {\n    baseComplete(this);\n  },\n  pipe: function pipe() {\n    return _pipe.apply(void 0, arguments)(this);\n  },\n  nextGuard: function nextGuard() {\n    return baseNextGuard(this);\n  },\n  onStart: function onStart() {},\n  onStop: function onStop() {},\n  getValue: function getValue() {\n    return this.val;\n  }\n};\nexport { proto };\nexport var baseProps = function baseProps(props) {\n  return Object.assign({}, {\n    active: false,\n    hasEmitted: false,\n    dependencies: [],\n    dependents: [],\n    subscribers: []\n  }, props);\n};","import { deactivateStream } from './helpers';\nimport { notifyUpTheChainOn } from './upchain-notification';\nexport function baseError(stream, error) {\n  // we want to call all subscribers' complete callback when\n  // all streams that have to be deactivated already have been\n  // but we also want to reset stream.subscribers because\n  // deactivationGuard checks that property\n  var subscribers = [].concat(stream.subscribers);\n  stream.subscribers = [];\n  deactivateStream(stream);\n  notifyUpTheChainOn(stream, 'error');\n  stream.dependents.forEach(function (d) {\n    return d.error(error);\n  });\n  subscribers.forEach(function (s) {\n    return s.error(error);\n  });\n}","import { proto, baseProps } from '../core/proto';\nexport function baseCreate(props, dependency) {\n  props.dependencies = dependency ? [dependency] : props.dependencies || [];\n  var stream = Object.assign(Object.create(proto), baseProps(props));\n  var nextFn = stream.next;\n\n  stream.next = function () {\n    if (stream.nextGuard()) {\n      try {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        nextFn.call.apply(nextFn, [stream].concat(args));\n      } catch (error) {\n        //TODO: Write tests for this logic\n        if (stream.active) stream.error(error);else throw error;\n      }\n    }\n  };\n\n  stream.dependencies.forEach(function (s) {\n    return s.dependents.push(stream);\n  });\n  return stream;\n}","export function baseNext(stream, x) {\n  stream.hasEmitted = true;\n  stream.val = x;\n  stream.subscribers.forEach(function (s) {\n    return s.next(x);\n  });\n  stream.dependents.forEach(function (s) {\n    return s.next(x);\n  });\n  return stream;\n}\nexport var baseNextGuard = function baseNextGuard(stream) {\n  return stream.active === true;\n};","var temporaryQueue = [];\n\nvar queueDependencies = function queueDependencies(stream, predicate) {\n  var shouldQueue = function shouldQueue(d) {\n    return predicate(d) && temporaryQueue.indexOf(d) === -1;\n  };\n\n  stream.dependencies.filter(shouldQueue).forEach(function (d) {\n    return temporaryQueue.push(d);\n  });\n};\n\nexport var traverseUp = function traverseUp(stream, _ref) {\n  var predicate = _ref.predicate,\n      action = _ref.action,\n      actionGuard = _ref.actionGuard;\n  var s = stream;\n\n  predicate = predicate || function () {\n    return true;\n  };\n\n  actionGuard = actionGuard || function () {\n    return true;\n  };\n\n  queueDependencies(s, predicate);\n  s = temporaryQueue.shift();\n\n  while (s) {\n    if (actionGuard(s)) {\n      action(s);\n      queueDependencies(s, predicate);\n    }\n\n    s = temporaryQueue.shift();\n  }\n};","import * as helpers from './helpers';\nimport { traverseUp } from './traversals';\n\nvar onActivated = function onActivated(stream) {\n  var producerStreams = [];\n  traverseUp(stream, {\n    predicate: helpers.isInactive,\n    action: function action(s) {\n      helpers.activateStream(s);\n      helpers.isProducerStream(s) && producerStreams.push(s); //why not call start inline? see below.\n    }\n  });\n  producerStreams.forEach(helpers.startProducer);\n};\n\nvar onError = function onError(stream) {\n  return traverseUp(stream, {\n    predicate: helpers.isActive,\n    action: helpers.deactivateStream\n  });\n};\n\nvar onCompleted = function onCompleted(stream) {\n  return traverseUp(stream, {\n    predicate: helpers.isActive,\n    action: helpers.deactivateStream,\n    actionGuard: helpers.deactivationGuard\n  });\n};\n\nvar eventHandlers = {\n  activated: onActivated,\n  completed: onCompleted,\n  error: onError\n};\nexport var notifyUpTheChainOn = function notifyUpTheChainOn(stream, eventType) {\n  return eventHandlers[eventType](stream);\n}; // why not call s.producer.start right inline?\n// if we have something like this:\n// Stream.merge(Stream.of(1), Stream.of(2)).subscribe(..)\n// we want to first mark both 'of' streams as active\n// and only then let them start producing values\n// If we call producer.start inline we'd have:\n// of(1) calls next on merge with 1\n// of(1) completes and conditionally calls .complete() on all it's dependents\n// the condition being d.dependencies.every(dep => !dep.active)\n// of(2) however hasn't yet had it's active flag set to true so condition passes\n// as a result merge stream completes and doesn't emit 2","import { notifyUpTheChainOn } from './upchain-notification';\nimport { deactivateStream, hasNoActiveDependencies } from './helpers';\nexport function baseComplete(stream) {\n  // we want to call all subscribers' complete callback when\n  // all streams that have to be deactivated already have been\n  // but we also want to reset stream.subscribers because\n  // deactivationGuard checks that property\n  var subscribers = [].concat(stream.subscribers);\n  stream.subscribers = [];\n  deactivateStream(stream);\n  notifyUpTheChainOn(stream, 'completed');\n  stream.dependents.filter(hasNoActiveDependencies).forEach(function (d) {\n    return d.complete();\n  });\n  subscribers.forEach(function (s) {\n    return s.complete();\n  });\n}","import { baseCreate } from '../internal';\nexport var create = function create(producer) {\n  if (producer === void 0) {\n    producer = {};\n  }\n\n  producer.start = producer.start || function () {};\n\n  producer.stop = producer.stop || function () {};\n\n  return baseCreate({\n    producer: producer\n  });\n};","import { baseCreate, baseNext } from '../internal';\nexport var filter = function filter(f) {\n  return function (stream) {\n    return baseCreate({\n      next: function next(x) {\n        if (f(x)) baseNext(this, x);\n      }\n    }, stream);\n  };\n};","import { baseCreate, baseNext, baseComplete } from '../internal';\nimport { toStream } from '../internal/helpers';\nexport var switchMap = function switchMap(fn, resultSelector) {\n  return function (stream) {\n    resultSelector = resultSelector || function (outerValue, innerValue) {\n      return innerValue;\n    };\n\n    var subscription;\n    var outerIndex = 0;\n    var sourceStreamHasCompleted;\n    var nestedStreamHasCompleted;\n    return baseCreate({\n      next: function next(outerValue) {\n        subscription && subscription.unsubscribe();\n        subscription = this.subscribeToInner({\n          outerValue: outerValue,\n          outerIndex: outerIndex++\n        });\n      },\n      onStop: function onStop() {\n        subscription && subscription.unsubscribe();\n        subscription = null;\n        outerIndex = 0;\n        sourceStreamHasCompleted = false;\n        nestedStreamHasCompleted = false;\n      },\n      complete: function complete() {\n        sourceStreamHasCompleted = true;\n        nestedStreamHasCompleted && baseComplete(this);\n      },\n      subscribeToInner: function subscribeToInner(_ref) {\n        var _this = this;\n\n        var outerValue = _ref.outerValue,\n            outerIndex = _ref.outerIndex;\n        var innerIndex = 0;\n        return toStream(fn(outerValue, outerIndex)).subscribe(function (innerValue) {\n          return _this.tryNext(resultSelector.bind(_this, outerValue, innerValue, outerIndex, innerIndex++));\n        }, this.error.bind(this), this.innerStreamComplete.bind(this));\n      },\n      innerStreamComplete: function innerStreamComplete() {\n        nestedStreamHasCompleted = true;\n        sourceStreamHasCompleted && this.complete();\n      },\n      tryNext: function tryNext(fn) {\n        var result;\n\n        try {\n          result = fn();\n        } catch (e) {\n          this.error(e);\n        }\n\n        baseNext(this, result);\n      }\n    }, stream);\n  };\n};","import {create, subscribe} from 'stream-lite/es'\r\nimport {filter, switchMap} from 'stream-lite/es/operators'\r\n\r\nexport function createEpicMiddleware(epic, options = {}) {\r\n  const epic$ = create()\r\n  const action$ = create()\r\n\r\n  action$.ofType = type => action$.pipe(filter(action => action.type === type))\r\n\r\n  let store\r\n  const epicMiddleware = _store => {\r\n    store = _store\r\n    return next => {\r\n      epic$.pipe(\r\n        switchMap(epic => epic(action$, store, options.dependencies)),\r\n        subscribe(store.dispatch)\r\n      )\r\n\r\n      epic$.next(epic)\r\n\r\n      return action => {\r\n        const result = next(action)\r\n        action$.next(action)\r\n        return result\r\n      }\r\n    }\r\n  }\r\n\r\n  epicMiddleware.replaceEpic = epic => {\r\n    // gives the previous root Epic a last chance to do some clean up\r\n    store.dispatch({type: 'EPIC_END'})\r\n    // switches to the new root Epic, synchronously terminating the previous one\r\n    epic$.next(epic)\r\n  }\r\n\r\n  return epicMiddleware\r\n}\r\n","import { baseCreate } from '../internal';\n\nvar merge = function merge() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n\n  return baseCreate({\n    dependencies: streams\n  });\n};\n\nexport { merge };","import {merge} from 'stream-lite/es/statics'\r\n\r\nexport const combineEpics = (...epics) => (...args) =>\r\n  merge(...epics.map(epic => epic(...args)))\r\n"],"names":["isActive","s","active","isInactive","isProducerStream","dependencies","length","producer","toStream","then","promise","create","cancelled","start","self","_this","this","next","complete","x","error","onStop","hasNoSubscribers","subscribers","hasNoActiveDependencies","every","hasNoActiveDependents","dependents","removeSubscriber","subscriber","filter","sub","deactivationGuard","activateStream","hasEmitted","onStart","startProducer","deactivateStream","stop","subscribe","nextOrSubscriber","err","Error","stream","push","helpers.activateStream","helpers.isProducerStream","helpers.startProducer","notifyUpTheChainOn","unsubscribe","helpers.hasNoSubscribers","helpers.removeSubscriber","helpers.hasNoActiveDependents","helpers.deactivateStream","proto","_subscribe","apply","arguments","value","baseNext","_error","concat","forEach","d","baseError","baseComplete","pipe","_len","fns","Array","_key","reduce","f","g","_pipe","nextGuard","baseNextGuard","getValue","val","baseProps","props","Object","assign","baseCreate","dependency","nextFn","args","call","temporaryQueue","queueDependencies","predicate","indexOf","traverseUp","_ref","action","actionGuard","shift","eventHandlers","activated","producerStreams","helpers.isInactive","completed","helpers.isActive","helpers.deactivationGuard","eventType","switchMap","fn","resultSelector","subscription","outerValue","innerValue","sourceStreamHasCompleted","nestedStreamHasCompleted","outerIndex","subscribeToInner","innerIndex","tryNext","bind","innerStreamComplete","result","e","epic","options","const","store","epic$","action$","ofType","type","epicMiddleware","_store","dispatch","replaceEpic","streams","epics","map"],"mappings":"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"}